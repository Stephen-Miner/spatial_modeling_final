<!DOCTYPE html>
<html lang="en">
<head>
    <title>CPSC 487/587</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@1.5.1/quaternion.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from "./js/utils/utils_three.js";
    import {TransformGizmoEngine} from "./js/utils/utils_transform_gizmo.js";
    import {get_default_lil_gui} from "./js/utils/utils_three.js";
    import {add_matrix_matrix, mul_matrix_scalar} from "./js/utils/utils_math.js";
    import {refresh_displays} from "./js/utils/utils_three.js";
    import {set_object_pose_from_SE3_matrix} from "./js/utils/utils_transforms.js";
    import {mul_matrix_matrix} from "./js/utils/utils_math.js";


    let engine = ThreeEngine.new_default_3d();

    let global_settings = {
        ORBIT_LINE_SEGMENTS : 10
    };

    let earth = {
        t: 0,
        a: 7,
        b: 4,
        theta_1: 0,
        theta_2: 0,
        theta_3: 0,
        speed: 1
    };

    let gui = get_default_lil_gui();

    gui.add(global_settings, "ORBIT_LINE_SEGMENTS", 3, 1000);
    let earth_controls = gui.addFolder("Earth Controls");
    earth_controls.add(earth, "theta_1", -2 * Math.PI, 2 * Math.PI);
    earth_controls.add(earth, "theta_2", -2 * Math.PI, 2 * Math.PI);
    earth_controls.add(earth, "theta_3", -2 * Math.PI, 2 * Math.PI);
    earth_controls.add(earth, "speed", -3, 3);


    function draw_orbit (engine, num_line_segments, planet) {
        let increment = Math.PI / (num_line_segments)
        let points = []

        let planet_so3 = [
            [Math.cos(planet.theta_2) * Math.cos(planet.theta_3), -Math.cos(planet.theta_2)*Math.sin(planet.theta_3), Math.sin(planet.theta_2)],
            [Math.cos(planet.theta_3) * Math.sin(planet.theta_1) * Math.sin(planet.theta_2) + Math.cos(planet.theta_1) * Math.sin(planet.theta_3), Math.cos(planet.theta_1) * Math.cos(planet.theta_3) - Math.sin(planet.theta_1) * Math.sin(planet.theta_2) * Math.sin(planet.theta_3), -Math.cos(planet.theta_2) * Math.sin(planet.theta_1)],
            [-Math.cos(planet.theta_1) * Math.cos(planet.theta_3) * Math.sin(planet.theta_2) + Math.sin(planet.theta_1) * Math.sin(planet.theta_3), Math.cos(planet.theta_3) * Math.sin(planet.theta_1) + Math.cos(planet.theta_1) * Math.sin(planet.theta_2) * Math.sin(planet.theta_3), Math.cos(planet.theta_1) * Math.cos(planet.theta_2)]
        ];

        for(let i = 0; i < num_line_segments; i++) {
            let planet_t_1 = [
                [planet.a * Math.sin(increment * (i*2))],
                [planet.b * Math.cos(increment * (i*2))],
                [0]
            ];
            let planet_t_2 = [
                [planet.a * Math.sin(increment * (i+1)*2)],
                [planet.b * Math.cos(increment * (i+1)*2)],
                [0]
            ];

            let point_1 = mul_matrix_matrix(planet_so3, planet_t_1);
            let point_2 = mul_matrix_matrix(planet_so3, planet_t_2);
            engine.draw_debug_line(point_1, point_2, true, 0.02)
        }

    }

    engine.animation_loop( ()  => {
        earth.t = earth.t + engine.get_delta_time_from_last_frame() * (earth.speed * Math.PI);

        let earth_so3 = [
            [Math.cos(earth.theta_2) * Math.cos(earth.theta_3), -Math.cos(earth.theta_2)*Math.sin(earth.theta_3), Math.sin(earth.theta_2)],
            [Math.cos(earth.theta_3) * Math.sin(earth.theta_1) * Math.sin(earth.theta_2) + Math.cos(earth.theta_1) * Math.sin(earth.theta_3), Math.cos(earth.theta_1) * Math.cos(earth.theta_3) - Math.sin(earth.theta_1) * Math.sin(earth.theta_2) * Math.sin(earth.theta_3), -Math.cos(earth.theta_2) * Math.sin(earth.theta_1)],
            [-Math.cos(earth.theta_1) * Math.cos(earth.theta_3) * Math.sin(earth.theta_2) + Math.sin(earth.theta_1) * Math.sin(earth.theta_3), Math.cos(earth.theta_3) * Math.sin(earth.theta_1) + Math.cos(earth.theta_1) * Math.sin(earth.theta_2) * Math.sin(earth.theta_3), Math.cos(earth.theta_1) * Math.cos(earth.theta_2)]
        ];

        let earth_t = [
            [earth.a * Math.sin(earth.t)],
            [earth.b * Math.cos(earth.t)],
            [0]
        ];

        let earth_point = mul_matrix_matrix(earth_so3, earth_t);

        engine.draw_debug_sphere(earth_point, 0.5, 0x135c1b);
        engine.draw_debug_sphere([0,0,0], 1.0, 0xf6ff47);
        draw_orbit(engine, global_settings.ORBIT_LINE_SEGMENTS, earth)
    });

</script>
</body>
</html>